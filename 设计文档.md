Rauzy分形分析工作台 - 详尽设计文档
版本: 2.0
目标受众: AI工程师、前端开发者、对计算几何与符号动力学感兴趣的研究者
1. 概述 (Overview)
本项目是一个基于React的单页交互式Web应用（SPA），其核心目标是提供一个专业级的可视化分析工具，用于研究三阶斐波那契（Tribonacci）符号序列的代数性质与其几何体现——劳齐分形（Rauzy Fractal）之间的深刻联系。
应用允许用户通过直观的UI，手动构建、管理并同时探测多条复合路径（Composite Paths）。它利用刘氏定理的精确公式，实时计算出这些代数模式对应的几何点集，并在分形上以不同颜色高亮。一个同步的数据面板则展示了每条路径的详细计算结果，从而实现了代数理论与几何形态的同步验证与对比研究。
核心技术栈:
前端框架: React 18 (Hooks: useState, useEffect, useMemo, useRef)
数学计算: math.js
图形渲染: HTML5 Canvas API (2D Context)
样式: Tailwind CSS
2. 设计哲学 (Design Philosophy)
本应用的设计摒弃了传统的线性报告模式，采用了一个信息密度更高的三栏式“全屏冻结工作台”布局。此设计哲学的核心是为PC端的研究工作流服务，确保所有关键信息和交互控件始终可见，无需滚动页面。
左侧控制栏: 集中了所有的输入和控制功能（路径构建、路径列表、点数调整），作为操作的起点。
中间画布区: 视觉中心，以固定的4:3宽高比展示分形，确保几何形态的稳定呈现。
右侧数据栏: 作为输出和分析的核心区域，实时展示所有路径的计算数据，便于横向对比和深入研究。
这种布局将“输入 -> 可视化 -> 数据输出”的研究流程固化在界面上，为用户，特别是需要进行大量重复实验的AI Agent，提供了最高效、最专注的工作环境。
3. 架构设计 (Architectural Design)
应用采用了一种**“重计算-轻渲染”分离**的架构，确保在处理大规模数据时UI的流畅性。
3.1. 状态管理与数据流 (State Management & Data Flow)
源头状态 (Source of Truth):
numPoints: 用户设定的总点数。这是触发最重量级计算的唯一状态。
pathsData: 一个包含所有路径及其计算结果的对象数组。这是触发中等重量级计算和渲染更新的核心状态。
baseData: 一个包含“重量级”计算结果的对象，格式为 { word, pointsWithBaseType, indexMaps }。它仅在numPoints改变时才会被重新计算。
派生状态 (Derived State):
renderedPoints: **（关键）**这是一个通过useMemo钩子派生出的状态。它不是一个独立的useState，而是根据baseData和pathsData这两个“源头”状态即时计算生成的。
const renderedPoints = useMemo(() => {
    // ...根据baseData和pathsData计算出最终要渲染的点集
}, [baseData, pathsData]);

这种模式确保了渲染数据与源头状态的绝对同步，从根本上避免了因useEffect异步更新而导致的状态不一致问题（详见“避坑指南”）。
核心数据流:
点数变更 (numPoints): 触发useEffect，调用重量级的executeRauzyCoreAlgorithm函数，生成全新的baseData。baseData的更新会级联触发useMemo，重新计算renderedPoints，最终更新画布。
路径变更 (pathsData): 用户添加或删除路径。这不会重新计算baseData。它会直接触发useMemo，在现有的baseData上快速重新计算高亮信息，生成新的renderedPoints并更新画布。
4. 核心算法详解 (Core Algorithm Deep Dive)
4.1. executeRauzyCoreAlgorithm: 基础数据生成
此函数是应用的计算核心，严格遵循“劳齐分形核心算法”的六个步骤，其唯一职责是生成与点数相关的、后续所有计算都依赖的基础数据。
输入: targetPointCount (number)
输出: Object { word, pointsWithBaseType, indexMaps }
实现步骤:
步骤 1-3 (矩阵与变换): 动态计算替换矩阵M的特征值与特征向量，并最终获得用于投影的逆矩阵invBasisMatrix。
步骤 4 (生成序列): 通过循环迭代替换规则，生成一个长度不小于targetPointCount的Tribonacci词word。
步骤 5 (构建与投影): 遍历word，在循环中计算每个点的三维坐标，并通过invBasisMatrix投影，获得二维坐标(re, im)和其baseType。
步骤 6 (输出): 返回包含word、所有点的几何信息pointsWithBaseType，以及用于快速查找的基础位置数列indexMaps。
4.2. calculatePathData: 刘氏定理计算引擎
此函数是刘氏定理的直接代码实现，负责为单条路径计算其所有相关的代数数据。
输入: path (Array), indexMaps (Object), pointsWithBaseType (Array)
输出: Object { path, rp, cl, sequence, firstPointCoords }
实现逻辑:
计算主项系数: 根据路径总权重rp和预计算的斐波那契数列F，计算出主项P_L(k)中三个基础位置数列的系数。
计算常数项: 根据路径L的具体顺序和F，累加计算出常数项C_L。
计算复合位置数列: 循环k，利用主项系数、常数项和基础位置数列indexMaps，通过公式W_L(k) = P_L(k) - C_L计算出完整的复合位置数列sequence。
获取首项坐标: 利用sequence[0]找到首项在pointsWithBaseType中的索引，从而获得其坐标。
返回包含所有计算结果的完整数据对象。
5. 避坑指南 (Pitfall Guide)
问题：分形偶尔不显示或形状错误
原因: 在开发初期，我们发现动态计算投影矩阵invBasisMatrix时，math.js的eigs函数对于特征向量的返回顺序和符号有时存在不一致性，这会导致投影完全错误。
解决方案: 严格遵循您提供的、经过验证的动态计算代码。该代码通过标准化特征向量 (math.divide(vec, vec.get([0, 0]))) 等步骤，确保了每次计算都能得到一个稳定且正确的投影矩阵。切勿为了所谓的“性能”而轻易硬编码一个看似正确的矩阵，因为这可能隐藏了更深层次的计算错误。
问题：UI在处理大量点数时卡死
原因: 生成百万级别的分形点集是一个CPU密集型任务。如果直接在React的主线程中执行，会阻塞渲染，导致页面假死。
解决方案 (当前版本未采用，但为最佳实践): 将executeRauzyCoreAlgorithm函数整体移入一个Web Worker中。主线程仅负责发送numPoints并接收计算结果，所有繁重工作都在后台线程完成，从而保证UI的绝对流畅。当前版本使用了setTimeout作为一种轻量级的替代方案，但Web Worker是处理此问题的根本之道。
问题：添加新路径时，画布瞬间变白
原因: 这是由React的状态更新时序问题导致的。使用useEffect来根据pathsData的更新去计算并设置renderedPoints，这两个setState操作在不同的渲染周期中，中间可能存在一个renderedPoints为空的瞬间。
解决方案: 使用useMemo来定义renderedPoints。这使其成为一个派生状态，其计算和更新与它的依赖项baseData和pathsData在同一个渲染周期内同步完成，从根本上消除了时序问题。
问题：路径点数不达预期
原因: 在calculatePathData函数中，对k的循环设置了一个硬编码的上限（如100），导致无法找到路径的所有出现位置。
解决方案: 移除硬编码上限，让循环的次数由基础位置数列的实际长度maxBaseLength决定，从而确保计算出完整的复合位置数列。
6. 核心代码附录
executeRauzyCoreAlgorithm (核心投影算法)
const executeRauzyCoreAlgorithm = (targetPointCount) => {
    if (typeof math === 'undefined') return null;
    
    // 步骤 1-3: 矩阵与坐标变换 (使用您指定的动态计算方法)
    const M = math.matrix([[1, 1, 1], [1, 0, 0], [0, 1, 0]]);
    const eigenInfo = math.eigs(M);
    const eigenvalues = eigenInfo.values.toArray();
    const eigenvectors = eigenInfo.vectors;
    const expandingIndex = eigenvalues.findIndex(val => typeof val === 'number' && Math.abs(val) > 1);
    let expandingVec = math.column(eigenvectors, expandingIndex);
    const complexIndex = eigenvalues.findIndex(val => typeof val === 'object');
    let complexVec = math.column(eigenvectors, complexIndex);
    expandingVec = math.divide(expandingVec, expandingVec.get([0, 0]));
    complexVec = math.divide(complexVec, complexVec.get([0, 0]));
    const contractingVecReal = math.re(complexVec);
    const contractingVecImag = math.im(complexVec);
    const basisMatrix = math.transpose(math.matrix([
        expandingVec.toArray().flat(),
        contractingVecReal.toArray().flat(),
        contractingVecImag.toArray().flat()
    ]));
    const invBasisMatrix = math.inv(basisMatrix);

    // ... 后续步骤 ...
    
    return { word, pointsWithBaseType, indexMaps };
};


7. 附录 A: 刘氏定理原文 (m=3)
1. 预备知识与定义 (Preliminaries and Definitions)
定义 1.1：三阶斐波那契替换系统 (The Tribonacci Substitution System)
令字母表为 $ \Sigma_3 = {1,2,3} $。三阶斐波那契替换 sigma_3:Sigma_3\*rightarrowSigma_3\* 是一个由以下规则定义的同态：
sigma_3(1)=12
sigma_3(2)=13
sigma_3(3)=1
通过对 1 进行无限次迭代，即 $ \lim_{n \to \infty} \sigma_3^n(1) $，可以生成一个唯一的右无限词（不动点），我们将其记为 $ S_{\infty}^{(3)} $。该词被称为三阶斐波那契词（Tribonacci word）。
定义 1.2：三阶斐波那契数列 (The Tribonacci Sequence)
三阶斐波那契数列 F_k(3)∗kinmathbbZ 是一个三阶线性递推数列，其定义为：
F_k(3)=F∗k−1(3)+F_k−2(3)+F_k−3(3)
其标准初始条件为 $ F_0^{(3)} = 0, F_1^{(3)} = 0, F_2^{(3)} = 1 $。该数列可以双向延伸至负整数索引，例如 $ F_{-1}^{(3)} = 1, F_{-2}^{(3)} = -1, F_{-3}^{(3)} = 0 $。
定义 1.3：位置函数与复合路径 (Position Functions and Composite Paths)
基础位置函数 (Base Position Function)：对于任意 $ i \in {1,2,3} $，函数 W_i(3)(k) 给出字母 i 在 S_infty(3) 中第 k 次出现的位置（索引从 1 开始）。
复合路径 (Composite Path)：一个复合路径 L 是一个由 1,2,3 中元素构成的有限序列，记为 $ L = (l_1, l_2, \dots, l_p) $。
复合位置函数 (Composite Position Function)：对于给定的路径 $ L $，其复合位置函数 W_L(3)(k) 定义为基础位置函数的从右至左的复合：
W_L(3)(k):=(W_l_1(3)circW_l_2(3)circdotscircW_l_p(3))(k)
该函数描述了在 S_infty(3) 中一个嵌套模式的位置。
2. 定理陈述 (Statement of the Theorem for m=3)
定理 2.1 (刘氏定理, m=3)
对于任意复合路径 $ L=(l_1, \dots, l_p) $，其中 $ l_j \in {1,2,3} $，以及任意正整数 $ k $，复合位置函数 W_L(3)(k) 具有如下的精确分解形式：
WL(3)​(k)=PL(3)​(k)−CL(3)​
其中 P_L(3)(k) 为主项 (Principal Term)，是一个关于基础位置函数的线性组合；$ C_L^{(3)} $ 为常数项 (Constant Term)，是一个仅依赖于路径 L 的整数。
A. 主项 P_L(3)(k) 的定义
主项是基础位置函数 W_i(3)(k) 的线性组合，其系数仅由路径的总权重 r_p=sum_j=1pl_j 决定，而与路径 L 中元素的具体顺序无关。
PL(3)​(k)=i=1∑3​(j=1∑i​Frp​−j−1(3)​)Wi(3)​(k)
这一性质揭示了主项的准交换性 (quasi-commutativity)。
B. 常数项 C_L(3) 的定义
常数项是一个路径依赖的整数，其值通过对路径各步骤贡献的累加得到。令 r_s=sum_j=1sl_j 为路径的前 s 步权重和，则常数项的计算公式为：
CL(3)​=s=1∑p​(j=1∑3−ls​​Frs​+j−2(3)​)
该项精确地捕捉了由于路径顺序不同而产生的非交换性效应。
